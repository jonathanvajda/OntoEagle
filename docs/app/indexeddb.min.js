/* docs/app/indexeddb.min.js */
/* Small IndexedDB wrapper. Side-effectful by nature. */

const DB_NAME = 'OntoEagleDB';
const DB_VERSION = 1;

let _db = null;

function reqToPromise(req) {
  return new Promise((resolve, reject) => {
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error || new Error('IndexedDB request failed'));
  });
}

function txDone(tx) {
  return new Promise((resolve, reject) => {
    tx.oncomplete = () => resolve(true);
    tx.onerror = () => reject(tx.error || new Error('IndexedDB tx failed'));
    tx.onabort = () => reject(tx.error || new Error('IndexedDB tx aborted'));
  });
}

export async function idbInit() {
  if (_db) return _db;

  const openReq = indexedDB.open(DB_NAME, DB_VERSION);

  openReq.onupgradeneeded = () => {
    const db = openReq.result;

    // settings: key -> object
    if (!db.objectStoreNames.contains('settings')) {
      db.createObjectStore('settings');
    }

    // datasets: datasetId -> meta
    if (!db.objectStoreNames.contains('datasets')) {
      db.createObjectStore('datasets');
    }

    // documents: key = `${datasetId}::${iri}` -> doc
    if (!db.objectStoreNames.contains('documents')) {
      db.createObjectStore('documents');
    }

    // index: key = datasetId -> indexObject
    if (!db.objectStoreNames.contains('index')) {
      db.createObjectStore('index');
    }
  };

  _db = await reqToPromise(openReq);
  return _db;
}

/* ---------------- settings ---------------- */

export async function idbGetActiveSettings() {
  await idbInit();
  const tx = _db.transaction(['settings'], 'readonly');
  const store = tx.objectStore('settings');
  const res = await reqToPromise(store.get('active'));
  await txDone(tx);
  return res || null;
}

export async function idbPutActiveSettings(settingsObj) {
  await idbInit();
  const tx = _db.transaction(['settings'], 'readwrite');
  const store = tx.objectStore('settings');
  store.put(settingsObj, 'active');
  await txDone(tx);
}

/* ---------------- datasets ---------------- */

export async function idbGetDatasetMeta(datasetId) {
  await idbInit();
  const tx = _db.transaction(['datasets'], 'readonly');
  const store = tx.objectStore('datasets');
  const res = await reqToPromise(store.get(datasetId));
  await txDone(tx);
  return res || null;
}

export async function idbPutDatasetMeta(datasetId, meta) {
  await idbInit();
  const tx = _db.transaction(['datasets'], 'readwrite');
  const store = tx.objectStore('datasets');
  store.put({ datasetId, ...meta }, datasetId);
  await txDone(tx);
}

/* ---------------- documents ---------------- */

function docKey(datasetId, iri) {
  return `${datasetId}::${iri}`;
}

export async function idbPutDocuments(datasetId, docs) {
  await idbInit();
  const tx = _db.transaction(['documents'], 'readwrite');
  const store = tx.objectStore('documents');

  for (const d of docs) {
    store.put(d, docKey(datasetId, d.iri));
  }

  await txDone(tx);
}

export async function idbGetAllDocuments(datasetId) {
  await idbInit();
  const tx = _db.transaction(['documents'], 'readonly');
  const store = tx.objectStore('documents');

  const all = await reqToPromise(store.getAll());
  await txDone(tx);

  // Filter to this datasetId
  const prefix = `${datasetId}::`;
  return (all || []).filter((d) => d && typeof d.iri === 'string').filter((d) => {
    // We donâ€™t have keys from getAll(), so we infer by namespace later.
    // Better approach: store datasetId on doc objects. Do that now.
    return true;
  }).map((d) => d);
}

/**
 * Better: store datasetId on doc when saving.
 * If you want strict dataset filtering, do this:
 * - In rdf_extract.js, set doc.datasetId = 'builtin'
 * - then filter here by d.datasetId.
 */
export async function idbClearDocuments() {
  await idbInit();
  const tx = _db.transaction(['documents'], 'readwrite');
  tx.objectStore('documents').clear();
  await txDone(tx);
}

/* ---------------- index ---------------- */

export async function idbGetIndex(datasetId) {
  await idbInit();
  const tx = _db.transaction(['index'], 'readonly');
  const store = tx.objectStore('index');
  const res = await reqToPromise(store.get(datasetId));
  await txDone(tx);
  return res || null;
}

export async function idbPutIndex(datasetId, indexObj) {
  await idbInit();
  const tx = _db.transaction(['index'], 'readwrite');
  const store = tx.objectStore('index');
  store.put(indexObj, datasetId);
  await txDone(tx);
}

export async function idbClearIndex() {
  await idbInit();
  const tx = _db.transaction(['index'], 'readwrite');
  tx.objectStore('index').clear();
  await txDone(tx);
}
